#ifndef MatlabDynamicTyping_H
#define MatlabDynamicTyping_H

#include <variant>
#include <string>
#include <iostream>
#include <math.h>
#include <MatlabPrinting>

#if defined(MATLAB_MEX_FILE)
#include "matrix.h"
#endif

namespace Matlab{
	
enum NULL_STATE{
	UNITIALIZED,
	EMPTY
};
	
class DynamicType{
	private:
		std::variant<
			double,
			float,
			int,
			bool,
			char,
			std::string,
			NULL_STATE
		> data;
		char* name = NULL;
		
	private:
		static std::string doubleToString(double num){
			return fmod(num,1)==0 ? std::to_string((int)num) : std::to_string(num);
		}
		
		static void error(std::string message){
			#if defined(MATLAB_MEX_FILE)
			mexErrMsgTxt(message.c_str());
			#else
			std::cout << "ERROR: " << message << std::endl;
			throw(1);
			#endif
		}
		
		void checkForUndefined(){
			if( std::holds_alternative<NULL_STATE>(data) &&
					std::get<NULL_STATE>(data)==UNITIALIZED ){
						
				if(name!=NULL){
					error(std::string("Undefined function or variable '") + name + "'.");
				}else{
					error("Undefined function or variable without a name.");
				}
			}
		}
		
	public:
		DynamicType(){ data = UNITIALIZED; }
		DynamicType(double data){ this->data = data; }
		DynamicType(float data){ this->data = data; }
		DynamicType(int data){ this->data = data; }
		DynamicType(bool data){ this->data = data; }
		DynamicType(char data){ this->data = data; }
		DynamicType(std::string data){ this->data = data; }
		DynamicType(char* name){ this->name = name; data = UNITIALIZED; }
		
		void operator=(DynamicType& rhs){
			rhs.checkForUndefined();
			data = rhs.data;
		}
		
		friend std::ostream& operator<< (std::ostream& stream, const DynamicType& type){
			if( std::holds_alternative<double>(type.data) ){
				stream << std::get<double>(type.data);
			}else if( std::holds_alternative<float>(type.data) ){
				stream << std::get<float>(type.data);
			}else if( std::holds_alternative<int>(type.data) ){
				stream << std::get<int>(type.data);
			}else if( std::holds_alternative<bool>(type.data) ){
				stream << std::get<bool>(type.data);
			}else if( std::holds_alternative<char>(type.data) ){
				stream << std::get<char>(type.data);
			}else{
				stream << std::get<std::string>(type.data);
			}
        }
		
		std::string toString(){
			if( std::holds_alternative<double>(data) ){
				return doubleToString(std::get<double>(data));
			}else if( std::holds_alternative<float>(data) ){
				return doubleToString(std::get<float>(data));
			}else if( std::holds_alternative<int>(data) ){
				return std::to_string(std::get<int>(data));
			}else if( std::holds_alternative<bool>(data) ){
				return boolToString(std::get<bool>(data));
			}else if( std::holds_alternative<char>(data) ){
				return std::to_string(std::get<char>(data));
			}else{
				return std::get<std::string>(data);
			}
		}
		
		std::string getMatlabAssignmentString(){
			if( std::holds_alternative<double>(data) ){
				return doubleToString(std::get<double>(data));
			}else if( std::holds_alternative<float>(data) ){
				return doubleToString(std::get<float>(data));
			}else if( std::holds_alternative<int>(data) ){
				return std::to_string(std::get<int>(data));
			}else if( std::holds_alternative<bool>(data) ){
				return boolToString(std::get<bool>(data));
			}else if( std::holds_alternative<char>(data) ){
				return "'" + std::to_string(std::get<char>(data)) + "'";
			}else{
				return "\"" + std::get<std::string>(data) + "\"";
			}
		}
		
		#if defined(MATLAB_MEX_FILE)
		DynamicType(mxArray* pr){
			if( mxIsDouble(pr) ){
				data = mxGetScalar(pr);
			}else if( mxIsClass(pr, "logical") ){
				data = (bool)mxGetScalar(pr);
			}else if( mxIsChar(pr) ){
				data = (char)mxGetScalar(pr);
			}else if( mxIsClass(pr, "single") ){
				data = (float)mxGetScalar(pr);
			}else if( mxIsClass(pr, "string") ){				
				//Matlab's String class is encapsulated,
				//use Matlab call to convert it to char array
				mxArray *string_class[1], *char_array[1];
				string_class[0] = pr;
				mexCallMATLAB(1, char_array, 1, string_class, "char");
				
				//Parse the char array to create an std::string
				int buflen = mxGetN(char_array[0])*sizeof(mxChar)+1;
				char* buf = new char[buflen];
				mxGetString(char_array[0],buf,buflen);
				data = std::string(buf);
				delete buf;
			}else{
				error("TRANSLATOR ERROR: Input has unsupported class type.");
			}
		}
		
		void setMatlabValue(mxArray*& pr){
			if( std::holds_alternative<double>(data) ){
				pr = mxCreateDoubleMatrix(1, 1, mxREAL);
				double* output = mxGetPr(pr);
				output[0] = std::get<double>(data);
			}else if( std::holds_alternative<float>(data) ){
				const mwSize out[1] = {1};
				pr = mxCreateNumericArray(1, out, mxSINGLE_CLASS, mxREAL);
				float* output = (float*)mxGetPr(pr);
				output[0] = std::get<float>(data);
			}else if( std::holds_alternative<int>(data) ){
				pr = mxCreateDoubleMatrix(1, 1, mxREAL);
				double* output = mxGetPr(pr);
				output[0] = std::get<int>(data);
			}else if( std::holds_alternative<bool>(data) ){
				pr = mxCreateLogicalMatrix(1, 1);
				bool* output = (bool*)mxGetPr(pr);
				output[0] = std::get<bool>(data);
			}else if( std::holds_alternative<char>(data) ){
				const mwSize out[1] = {1};
				pr = mxCreateCharArray(1, out);
				char* output = (char*)mxGetPr(pr);
				output[0] = std::get<char>(data);
			}else if( std::holds_alternative<std::string>(data) ){
				//Matlab's string has a classdef, need Matlab to convert a char array to string
				mxArray* rhs = mxCreateString(std::get<std::string>(data).c_str());
				mexCallMATLAB(1, &pr, 1, &rhs, "string");
			}else{
				pr = mxCreateString(std::get<std::string>(data).c_str());
			}
		}
		#endif
		
		
		DynamicType operator+(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return DynamicType( std::get<double>(data) + rhs );
			}else if( std::holds_alternative<float>(data) ){
				return DynamicType( std::get<float>(data) + rhs );
			}else if( std::holds_alternative<int>(data) ){
				return DynamicType( std::get<int>(data) + rhs );
			}else if( std::holds_alternative<bool>(data) ){
				return DynamicType( std::get<bool>(data) + rhs );
			}else if( std::holds_alternative<char>(data) ){
				return DynamicType( std::get<char>(data) + rhs );
			}else if( std::holds_alternative<std::string>(data) ){
				return DynamicType( std::get<std::string>(data) + doubleToString(rhs) );
			}else{
				checkForUndefined();
			}
		}
		
		friend DynamicType operator+(const double lhs, DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return DynamicType( lhs + std::get<double>(rhs.data) );
			}else if( std::holds_alternative<float>(rhs.data) ){
				return DynamicType( lhs + std::get<float>(rhs.data) );
			}else if( std::holds_alternative<int>(rhs.data) ){
				return DynamicType( lhs + std::get<int>(rhs.data) );
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return DynamicType( lhs + std::get<bool>(rhs.data) );
			}else if( std::holds_alternative<char>(rhs.data) ){
				return DynamicType( lhs + std::get<char>(rhs.data) );
			}else if( std::holds_alternative<std::string>(rhs.data) ){
				return DynamicType( doubleToString(lhs) + std::get<std::string>(rhs.data) );
			}else{
				rhs.checkForUndefined();
			}
		}
		
		std::string operator+(const std::string& rhs){
			if( std::holds_alternative<double>(data) ){
				return doubleToString(std::get<double>(data)) + rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::to_string(std::get<float>(data)) + rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::to_string(std::get<int>(data)) + rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return boolToString(std::get<bool>(data)) + rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) + rhs;
			}else if( std::holds_alternative<std::string>(data) ){
				return std::get<std::string>(data) + rhs;
			}else{
				checkForUndefined();
			}
		}
		
		friend std::string operator+(const std::string& lhs, DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs + doubleToString(std::get<double>(rhs.data));
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs + std::to_string(std::get<float>(rhs.data));
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs + std::to_string(std::get<int>(rhs.data));
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs + boolToString(std::get<bool>(rhs.data));
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs + std::get<char>(rhs.data);
			}else if( std::holds_alternative<std::string>(rhs.data) ){
				return lhs + std::get<std::string>(rhs.data);
			}else{
				rhs.checkForUndefined();
			}
		}
		
		DynamicType operator+(DynamicType& rhs){
			if( std::holds_alternative<double>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					return DynamicType( doubleToString(std::get<double>(data)) + std::get<std::string>(rhs.data) );
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<float>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					return DynamicType( std::to_string(std::get<float>(data)) + std::get<std::string>(rhs.data) );
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<int>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					return DynamicType( std::to_string(std::get<int>(data)) + std::get<std::string>(rhs.data) );
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<bool>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					return DynamicType( boolToString(std::get<bool>(data)) + std::get<std::string>(rhs.data) );
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<char>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<std::string>(rhs.data) );
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<std::string>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + doubleToString(std::get<double>(rhs.data)) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + std::to_string(std::get<float>(rhs.data)) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + std::to_string(std::get<int>(rhs.data)) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + boolToString(std::get<bool>(rhs.data)) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + std::get<std::string>(rhs.data) );
				}else{
					rhs.checkForUndefined();
				}
			}else{
				checkForUndefined();
			}
		}
		
		DynamicType operator-(DynamicType& rhs){
			if( std::holds_alternative<double>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					error("Undefined operator '-' for input arguments of type 'string'.");
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<float>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					error("Undefined operator '-' for input arguments of type 'string'.");
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<int>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					error("Undefined operator '-' for input arguments of type 'string'.");
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<bool>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					error("Undefined operator '-' for input arguments of type 'string'.");
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<char>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<char>(rhs.data) );
				}else if( std::holds_alternative<std::string>(rhs.data) ){
					error("Undefined operator '-' for input arguments of type 'string'.");
				}else{
					rhs.checkForUndefined();
				}
			}else if( std::holds_alternative<std::string>(data) ){
				error("Undefined operator '-' for input arguments of type 'string'.");
			}else{
				checkForUndefined();
			}
		}
		
		double operator*(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) * rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) * rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) * rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) * rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) * rhs;
			}else if( std::holds_alternative<std::string>(data) ){
				error("Undefined operator '*' for input arguments of type 'string'.");
			}else{
				checkForUndefined();
			}
		}
		
		friend double operator*(const double lhs, DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs * std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs * std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs * std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs * (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs * std::get<char>(rhs.data);
			}else if( std::holds_alternative<std::string>(rhs.data) ){
				error("Undefined operator '*' for input arguments of type 'string'.");
			}else{
				rhs.checkForUndefined();
			}
		}
		
		bool operator<(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) < rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) < rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) < rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) < rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) < rhs;
			}else if( std::holds_alternative<std::string>(data) ){
				error("Comparison between string and double is not supported.");
			}else{
				checkForUndefined();
			}
		}
		
		friend bool operator<(const double lhs, DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs < std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs < std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs < std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs < (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs < std::get<char>(rhs.data);
			}else if( std::holds_alternative<std::string>(rhs.data) ){
				error("Comparison between string and double is not supported.");
			}else{
				rhs.checkForUndefined();
			}
		}
		
		bool operator<=(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) <= rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) <= rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) <= rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) <= rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) <= rhs;
			}else if( std::holds_alternative<std::string>(data) ){
				error("Comparison between string and double is not supported.");
			}else{
				checkForUndefined();
			}
		}
		
		friend bool operator<=(const double lhs, DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs <= std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs <= std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs <= std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs <= (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs <= std::get<char>(rhs.data);
			}else if( std::holds_alternative<std::string>(rhs.data) ){
				error("Comparison between string and double is not supported.");
			}else{
				rhs.checkForUndefined();
			}
		}
		
		bool operator>(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) > rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) > rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) > rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) > rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) > rhs;
			}else if( std::holds_alternative<std::string>(data) ){
				error("Comparison between string and double is not supported.");
			}else{
				checkForUndefined();
			}
		}
		
		friend bool operator>(const double lhs, DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs > std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs > std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs > std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs > (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs > std::get<char>(rhs.data);
			}else if( std::holds_alternative<std::string>(rhs.data) ){
				error("Comparison between string and double is not supported.");
			}else{
				rhs.checkForUndefined();
			}
		}
		
		bool operator>=(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) >= rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) >= rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) >= rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) >= rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) >= rhs;
			}else if( std::holds_alternative<std::string>(data) ){
				error("Comparison between string and double is not supported.");
			}else{
				checkForUndefined();
			}
		}
		
		friend bool operator>=(const double lhs, DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs >= std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs >= std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs >= std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs >= (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs >= std::get<char>(rhs.data);
			}else if( std::holds_alternative<std::string>(rhs.data) ){
				error("Comparison between string and double is not supported.");
			}else{
				rhs.checkForUndefined();
			}
		}
		
		bool operator==(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) == rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) == rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) == rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) == rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) == rhs;
			}else if( std::holds_alternative<std::string>(data) ){
				error("Comparison between string and double is not supported.");
			}else{
				checkForUndefined();
			}
		}
		
		friend bool operator==(const double lhs, DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs == std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs == std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs == std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs == (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs == std::get<char>(rhs.data);
			}else if( std::holds_alternative<std::string>(rhs.data) ){
				error("Comparison between string and double is not supported.");
			}else{
				rhs.checkForUndefined();
			}
		}
};

};

#endif