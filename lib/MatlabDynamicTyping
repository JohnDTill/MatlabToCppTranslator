#ifndef MatlabDynamicTyping_H
#define MatlabDynamicTyping_H

#include <variant>
#include <string>
#include <iostream>
#include <math.h>

#if defined(MATLAB_MEX_FILE)
#include "matrix.h"
#endif

namespace Matlab{
	
class DynamicType{
	private:
		std::variant<double,float,int,bool,char,std::string> data;
		
	private:
		static std::string boolToString(bool b){
			return b ? "true" : "false";
		}
		
		static std::string doubleToString(double num){
			return fmod(num,1)==0 ? std::to_string((int)num) : std::to_string(num);
		}
		
		static void error(std::string message){
			#if defined(MATLAB_MEX_FILE)
			mexErrMsgTxt(message.c_str());
			#else
			std::cout << "ERROR: " << message << std::endl;
			throw(1);
			#endif
		}
		
	public:
		DynamicType(){}
		DynamicType(double data){ this->data = data; }
		DynamicType(float data){ this->data = data; }
		DynamicType(int data){ this->data = data; }
		DynamicType(bool data){ this->data = data; }
		DynamicType(char data){ this->data = data; }
		DynamicType(std::string data){ this->data = data; }
		
		void operator=(const DynamicType& rhs){ data = rhs.data; }
		
		friend std::ostream& operator<< (std::ostream& stream, const DynamicType& type){
			if( std::holds_alternative<double>(type.data) ){
				stream << std::get<double>(type.data);
			}else if( std::holds_alternative<float>(type.data) ){
				stream << std::get<float>(type.data);
			}else if( std::holds_alternative<int>(type.data) ){
				stream << std::get<int>(type.data);
			}else if( std::holds_alternative<bool>(type.data) ){
				stream << std::get<bool>(type.data);
			}else if( std::holds_alternative<char>(type.data) ){
				stream << std::get<char>(type.data);
			}else{
				stream << std::get<std::string>(type.data);
			}
        }
		
		#if defined(MATLAB_MEX_FILE)
		DynamicType(mxArray* pr){
			if( mxIsDouble(pr) ){
				data = mxGetScalar(pr);
			}else if( mxIsClass(pr, "logical") ){
				data = (bool)mxGetScalar(pr);
			}else if( mxIsChar(pr) ){
				data = (char)mxGetScalar(pr);
			}else if( mxIsClass(pr, "single") ){
				data = (float)mxGetScalar(pr);
			}else if( mxIsClass(pr, "string") ){
				mxArray* char_array = mxGetProperty(pr,0,"data");
				int buflen = mxGetN(char_array)*sizeof(mxChar)+1;
				char* buf = new char[buflen];
				mxGetString(char_array,buf,buflen);
				data = std::string(buf);
				delete buf;
				
				/*
				//This is the safe way to parse a string if the implementation
				//of string ever changes so that 'data' is not the correct field.
				
				//Matlab's String class is encapsulated,
				//use Matlab call to convert it to char array
				mxArray *string_class[1], *char_array[1];
				string_class[0] = pr;
				mexCallMATLAB(1, char_array, 1, string_class, "char");
				
				//Parse the char array to create an std::string
				int buflen = mxGetN(char_array[0])*sizeof(mxChar)+1;
				char* buf = new char[buflen];
				mxGetString(char_array[0],buf,buflen);
				data = std::string(buf);
				delete buf;
				*/
			}else{
				error("TRANSLATOR ERROR: Input has unsupported class type.");
			}
		}
		
		void setMatlabValue(mxArray*& pr){
			if( std::holds_alternative<double>(data) ){
				pr = mxCreateDoubleMatrix(1, 1, mxREAL);
				double* output = mxGetPr(pr);
				output[0] = std::get<double>(data);
			}else if( std::holds_alternative<float>(data) ){
				const mwSize out[1] = {1};
				pr = mxCreateNumericArray(1, out, mxSINGLE_CLASS, mxREAL);
				float* output = (float*)mxGetPr(pr);
				output[0] = std::get<float>(data);
			}else if( std::holds_alternative<int>(data) ){
				pr = mxCreateDoubleMatrix(1, 1, mxREAL);
				double* output = mxGetPr(pr);
				output[0] = std::get<int>(data);
			}else if( std::holds_alternative<bool>(data) ){
				pr = mxCreateLogicalMatrix(1, 1);
				bool* output = (bool*)mxGetPr(pr);
				output[0] = std::get<bool>(data);
			}else if( std::holds_alternative<char>(data) ){
				const mwSize out[1] = {1};
				pr = mxCreateCharArray(1, out);
				char* output = (char*)mxGetPr(pr);
				output[0] = std::get<char>(data);
			}else if( std::holds_alternative<std::string>(data) ){
				//Matlab's string has a classdef, need Matlab to convert a char array to string
				mxArray* rhs = mxCreateString(std::get<std::string>(data).c_str());
				mexCallMATLAB(1, &pr, 1, &rhs, "string");
			}else{
				pr = mxCreateString(std::get<std::string>(data).c_str());
			}
		}
		#endif
		
		
		DynamicType operator+(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return DynamicType( std::get<double>(data) + rhs );
			}else if( std::holds_alternative<float>(data) ){
				return DynamicType( std::get<float>(data) + rhs );
			}else if( std::holds_alternative<int>(data) ){
				return DynamicType( std::get<int>(data) + rhs );
			}else if( std::holds_alternative<bool>(data) ){
				return DynamicType( std::get<bool>(data) + rhs );
			}else if( std::holds_alternative<char>(data) ){
				return DynamicType( std::get<char>(data) + rhs );
			}else{
				return DynamicType( std::get<std::string>(data) + doubleToString(rhs) );
			}
		}
		
		friend DynamicType operator+(const double lhs, const DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return DynamicType( lhs + std::get<double>(rhs.data) );
			}else if( std::holds_alternative<float>(rhs.data) ){
				return DynamicType( lhs + std::get<float>(rhs.data) );
			}else if( std::holds_alternative<int>(rhs.data) ){
				return DynamicType( lhs + std::get<int>(rhs.data) );
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return DynamicType( lhs + std::get<bool>(rhs.data) );
			}else if( std::holds_alternative<char>(rhs.data) ){
				return DynamicType( lhs + std::get<char>(rhs.data) );
			}else{
				return DynamicType( doubleToString(lhs) + std::get<std::string>(rhs.data) );
			}
		}
		
		std::string operator+(const std::string& rhs){
			if( std::holds_alternative<double>(data) ){
				return doubleToString(std::get<double>(data)) + rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::to_string(std::get<float>(data)) + rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::to_string(std::get<int>(data)) + rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return boolToString(std::get<bool>(data)) + rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) + rhs;
			}else{
				return std::get<std::string>(data) + rhs;
			}
		}
		
		friend std::string operator+(const std::string& lhs, const DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs + doubleToString(std::get<double>(rhs.data));
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs + std::to_string(std::get<float>(rhs.data));
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs + std::to_string(std::get<int>(rhs.data));
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs + boolToString(std::get<bool>(rhs.data));
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs + std::get<char>(rhs.data);
			}else{
				return lhs + std::get<std::string>(rhs.data);
			}
		}
		
		DynamicType operator+(const DynamicType& rhs){
			if( std::holds_alternative<double>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<double>(data) + std::get<char>(rhs.data) );
				}else{
					return DynamicType( doubleToString(std::get<double>(data)) + std::get<std::string>(rhs.data) );
				}
			}else if( std::holds_alternative<float>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<float>(data) + std::get<char>(rhs.data) );
				}else{
					return DynamicType( std::to_string(std::get<float>(data)) + std::get<std::string>(rhs.data) );
				}
			}else if( std::holds_alternative<int>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<int>(data) + std::get<char>(rhs.data) );
				}else{
					return DynamicType( std::to_string(std::get<int>(data)) + std::get<std::string>(rhs.data) );
				}
			}else if( std::holds_alternative<bool>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<bool>(data) + std::get<char>(rhs.data) );
				}else{
					return DynamicType( boolToString(std::get<bool>(data)) + std::get<std::string>(rhs.data) );
				}
			}else if( std::holds_alternative<char>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<char>(data) + std::get<char>(rhs.data) );
				}else{
					return DynamicType( std::get<char>(data) + std::get<std::string>(rhs.data) );
				}
			}else{
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + doubleToString(std::get<double>(rhs.data)) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + std::to_string(std::get<float>(rhs.data)) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + std::to_string(std::get<int>(rhs.data)) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + boolToString(std::get<bool>(rhs.data)) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<std::string>(data) + std::get<char>(rhs.data) );
				}else{
					return DynamicType( std::get<std::string>(data) + std::get<std::string>(rhs.data) );
				}
			}
		}
		
		DynamicType operator-(const DynamicType& rhs){
			if( std::holds_alternative<double>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<double>(data) - std::get<char>(rhs.data) );
				}else{
					error("Undefined operator '-' for input arguments of type 'string'.");
				}
			}else if( std::holds_alternative<float>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<float>(data) - std::get<char>(rhs.data) );
				}else{
					error("Undefined operator '-' for input arguments of type 'string'.");
				}
			}else if( std::holds_alternative<int>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<int>(data) - std::get<char>(rhs.data) );
				}else{
					error("Undefined operator '-' for input arguments of type 'string'.");
				}
			}else if( std::holds_alternative<bool>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<bool>(data) - std::get<char>(rhs.data) );
				}else{
					error("Undefined operator '-' for input arguments of type 'string'.");
				}
			}else if( std::holds_alternative<char>(data) ){
				if( std::holds_alternative<double>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<double>(rhs.data) );
				}else if( std::holds_alternative<float>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<float>(rhs.data) );
				}else if( std::holds_alternative<int>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<int>(rhs.data) );
				}else if( std::holds_alternative<bool>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<bool>(rhs.data) );
				}else if( std::holds_alternative<char>(rhs.data) ){
					return DynamicType( std::get<char>(data) - std::get<char>(rhs.data) );
				}else{
					error("Undefined operator '-' for input arguments of type 'string'.");
				}
			}else{
				error("Undefined operator '-' for input arguments of type 'string'.");
			}
		}
		
		double operator*(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) * rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) * rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) * rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) * rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) * rhs;
			}else{
				error("Undefined operator '*' for input arguments of type 'string'.");
			}
		}
		
		friend double operator*(const double lhs, const DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs * std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs * std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs * std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs * (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs * std::get<char>(rhs.data);
			}else{
				error("Undefined operator '*' for input arguments of type 'string'.");
			}
		}
		
		bool operator<(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) < rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) < rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) < rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) < rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) < rhs;
			}else{
				error("Comparison between string and double is not supported.");
			}
		}
		
		friend bool operator<(const double lhs, const DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs < std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs < std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs < std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs < (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs < std::get<char>(rhs.data);
			}else{
				error("Comparison between string and double is not supported.");
			}
		}
		
		bool operator<=(const double rhs){
			if( std::holds_alternative<double>(data) ){
				return std::get<double>(data) <= rhs;
			}else if( std::holds_alternative<float>(data) ){
				return std::get<float>(data) <= rhs;
			}else if( std::holds_alternative<int>(data) ){
				return std::get<int>(data) <= rhs;
			}else if( std::holds_alternative<bool>(data) ){
				return (int)std::get<bool>(data) <= rhs;
			}else if( std::holds_alternative<char>(data) ){
				return std::get<char>(data) <= rhs;
			}else{
				error("Comparison between string and double is not supported.");
			}
		}
		
		friend bool operator<=(const double lhs, const DynamicType& rhs){
			if( std::holds_alternative<double>(rhs.data) ){
				return lhs <= std::get<double>(rhs.data);
			}else if( std::holds_alternative<float>(rhs.data) ){
				return lhs <= std::get<float>(rhs.data);
			}else if( std::holds_alternative<int>(rhs.data) ){
				return lhs <= std::get<int>(rhs.data);
			}else if( std::holds_alternative<bool>(rhs.data) ){
				return lhs <= (int)std::get<bool>(rhs.data);
			}else if( std::holds_alternative<char>(rhs.data) ){
				return lhs <= std::get<char>(rhs.data);
			}else{
				error("Comparison between string and double is not supported.");
			}
		}
};

};

#endif